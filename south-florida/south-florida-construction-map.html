<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
    <meta name="robots" content="noindex, nofollow" />
    <title>
        Miami Construction Map - The Real Deal
    </title>
    <link rel="icon" type="image/x-icon" href="https://therealdeal.com/favicon.ico" />
    <link rel="canonical" href="https://therealdeal.com/data/" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="true" />
    <link
      rel="stylesheet"
      href="https://fonts.googleapis.com/css2?family=Merriweather:wght@0,400;0,700;0,900&display=swap"
    />
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" />
    <link rel="stylesheet" href="https://api.mapbox.com/mapbox-gl-js/v3.5.1/mapbox-gl.css" />
    <link rel="stylesheet" href="../trd-data/common-map/map.css" />
    <style>
        /* Company list styling inside modal */
        .detail-value .company-list {
            margin: 0;
            padding-left: 1.15rem;
        }

        .detail-value .company-list li {
            list-style: disc;
            margin: 0;
            line-height: 1.25rem;
        }
    </style>

    <!-- Google Tag Manager -->
    <script>
        (function (w, d, s, l, i) {
            w[l] = w[l] || [];
            w[l].push({ "gtm.start": new Date().getTime(), event: "gtm.js" });
            var f = d.getElementsByTagName(s)[0],
                j = d.createElement(s),
                dl = l != "dataLayer" ? "&l=" + l : "";
            j.async = true;
            j.src = "https://www.googletagmanager.com/gtm.js?id=" + i + dl;
            f.parentNode.insertBefore(j, f);
        })(window, document, "script", "dataLayer", "GTM-K694XL6");
    </script>
    <!-- End Google Tag Manager -->
</head>

<body>
    <!-- Google Tag Manager (noscript) -->
    <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-K694XL6" height="0" width="0"
            style="display: none; visibility: hidden"></iframe></noscript>
    <!-- End Google Tag Manager (noscript) -->
    <script src="https://experience.tinypass.com/xbuilder/experience/load?aid=p7sVIGTDn5"></script>
    <script src="https://cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://api.mapbox.com/mapbox-gl-js/v3.5.1/mapbox-gl.js"></script>
    <script src="https://static.therealdeal.com/library/theme.js?v=1.0"></script>
    <script src="../trd-data/common-formatter/formatter.js"></script>
    <script src="../trd-data/common-loading/loading.js"></script>
    <script src="../trd-data/common-map/map.js?v=1.1"></script>
    <script src="filter-extension.js"></script>
    <script>
        // {map-url}?property-type="Residential"
        const queryParams = new URLSearchParams(window.location.search);
        const propertyType = queryParams.get("property-type");

        // Property Type based legend
        const legendKeys = [
            {
                title: "Property Type",
                options: [
                    {
                        text: "Residential",
                        value: "Residential",
                        default: true,
                        color: {
                            light: "#4287f5", // Blue for Residential
                            dark: "#6aa2f7"
                        },
                    },
                    {
                        text: "Commercial",
                        value: "Commercial",
                        default: false,
                        color: {
                            light: "#f58442", // Orange for Commercial
                            dark: "#f7a46a"
                        },
                    },
                    {
                        text: "Mixed/Other",
                        value: "Other",
                        default: false,
                        color: {
                            light: "#8c42f5", // Purple for Mixed/Other
                            dark: "#a46af7"
                        },
                    }
                ],
            },
        ];

        const tooltipDisplayFields = {
            title: { field: "PropertyAddress", label: "Address" },
            content: [
                { field: "PropertyType", label: "Property Type" },
                {
                    field: "LatestPermitIssuedDate",
                    label: "Latest Permit Issued Date",
                    format: "formatDate",
                },
                { field: "LatestPermitType", label:"Permit Type" },
            ],
        };

        const modalDisplayFields = {
            title: { field: "PropertyAddress", label: "Address" },
            content: [
                { field: "Neighborhood", label: "Neighborhood" },
                { field: "FolioHyperlink", label: "Folio Number" },
                { field: "PropertyType", label: "Property Type" },
                { field: "LatestPermitType", label:"Permit Type" },
                { field: "LatestApplicationType", label:"Application Type" },
                { field: "LatestProposedUse", label:"Proposed Use" },
                {
                    field: "LatestPermitIssuedDate",
                    label: "Latest Permit Issued Date",
                    format: "formatDate",
                },
                { field: "PermitCount", label: "Total Number of Permits", format: "formatNumber" }, 
                { field: "MaxEstimatedValue", label: "Total Construction Cost", format: "formatNumber" },
                { field: "MaxSquareFootage", label: "Total SQFT", format: "formatNumber" },
                { field: "MaxStructureUnits", label: "Number of Units"},
                { field: "MaxStructureFloors", label: "Number of Floors"},
                { field: "PermitNumber", label: "Past Permits" },
                { field: "DetailDescriptionComments", label: "Past Works" },
                {
                    field: "ArchitectName",
                    label: "Involved Architects",
                },
                {
                    field: "ContractorName",
                    label: "Involved Contractors",
                },
                {
                    field: "Link_Check",
                    label: "Property Reference Link",
                    format: "formatLink",
                },
            ],
        };

        const filterFields = [
            {
                title: "Property Type",
                name: "property-type",
                dataField: "PropertyType",
                fieldType: "checkbox",
                fieldLayoutClass: "checkbox-group",
                multiSelect: true,
                defaultValue: propertyType
                    ? propertyType.charAt(0).toUpperCase() + propertyType.slice(1)
                    : null,
                callback: (values, item) => {
                    return values.some((value) =>
                    item.properties["PropertyType"].includes(value)
                    );
                },
                options: [
                    {
                    label: "Residential",
                    value: "Residential",
                    },
                    {
                    label: "Commercial",
                    value: "Commercial",
                    },
                    {
                    label: "Mixed/Other",
                    value: "Other",
                    },
                ],
            },
            {
                title: "Total Square Footage",
                name: "sqft",
                dataField: "MaxSquareFootage",
                fieldType: "checkbox",
                fieldLayoutClass: "checkbox-group",
                multiSelect: true,
                defaultValue: null,
                callback: (values, item) => {
                    const sqftValue = item.properties?.MaxSquareFootage;
                    if (sqftValue === undefined || sqftValue === null) return false;
                    
                    // Convert to number if it's a string
                    const sqft = typeof sqftValue === 'string' ? 
                        parseFloat(sqftValue.replace(/,/g, '')) : 
                        Number(sqftValue);
                        
                    if (isNaN(sqft)) return false;
                    
                    // Check if sqft falls within any selected range
                    return values.some(value => {
                        const sqft_array = JSON.parse(value)
                        if (Array.isArray(sqft_array) && sqft_array.length === 2) {
                            const [minSqft, maxSqft] = sqft_array;
                            return sqft >= minSqft && sqft < maxSqft;
                        }
                        return false;
                    });
                },
                options: [
                    {
                        label: "< 5,000",
                        value: "[0, 5000]",
                    },
                    {
                        label: "5,000 to 10,000",
                        value: "[5000, 10000]",
                    },
                    {
                        label: "10,000 to 100,000",
                        value: "[10000, 100000]",
                    },
                    {
                        label: "100,000 +",
                        value: "[100000, 999999999999]",
                    },
                ],
            },
            {
                title: "Total Number of Units",
                name: "units",
                dataField: "MaxStructureUnits",
                fieldType: "checkbox",
                fieldLayoutClass: "checkbox-group",
                multiSelect: true,
                defaultValue: null,
                callback: (values, item) => {
                    const sqftValue = item.properties?.MaxStructureUnits;
                    if (sqftValue === undefined || sqftValue === null) return false;
                    
                    // Convert to number if it's a string
                    const sqft = typeof sqftValue === 'string' ? 
                        parseFloat(sqftValue.replace(/,/g, '')) : 
                        Number(sqftValue);
                        
                    if (isNaN(sqft)) return false;
                    
                    // Check if sqft falls within any selected range
                    return values.some(value => {
                        const sqft_array = JSON.parse(value)
                        if (Array.isArray(sqft_array) && sqft_array.length === 2) {
                            const [minSqft, maxSqft] = sqft_array;
                            return sqft >= minSqft && sqft < maxSqft;
                        }
                        return false;
                    });
                },
                options: [
                    {
                        label: "0",
                        value: "[0, 1]",
                    },
                    {
                        label: "1",
                        value: "[1, 2]",
                    },
                    {
                        label: "2 to 3",
                        value: "[2, 4]",
                    },
                    {
                        label: "4 to 10",
                        value: "[4, 10]",
                    },
                    {
                        label: "10 +",
                        value: "[10, 9999999999]",
                    },
                ],
            },
            {
                title: "Total Construction Cost",
                name: "cost",
                dataField: "MaxEstimatedValue",
                fieldType: "checkbox",
                fieldLayoutClass: "checkbox-group",
                multiSelect: true,
                defaultValue: null,
                callback: (values, item) => {
                    const costValue = item.properties?.MaxEstimatedValue;
                    if (costValue === undefined || costValue === null) return false;
                    
                    // Convert to number if it's a string
                    const cost = typeof costValue === 'string' ? 
                        parseFloat(costValue.replace(/,/g, '')) : 
                        Number(costValue);
                        
                    if (isNaN(cost)) return false;
                    
                    // Check if cost falls within any selected range
                    return values.some(value => {
                        const cost_array = JSON.parse(value)
                        if (Array.isArray(cost_array) && cost_array.length === 2) {
                            const [minCost, maxCost] = cost_array;
                            return cost >= minCost && cost < maxCost;
                        }
                        return false;
                    });
                },
                options: [
                    {
                        label: "< 100,000",
                        value: "[0, 100000]",
                    },
                    {
                        label: "100,000 to 1,000,000",
                        value: "[100000, 1000000]",
                    },
                    {
                        label: "1,000,000 to 10,000,000",
                        value: "[1000000, 10000000]",
                    },
                    {
                        label: "10,000,000 +",
                        value: "[10000000, 999999999999]",
                    },
                ],
            },
            {
                title: "Latest Permit Year",
                name: "year",
                dataField: "LatestPermitYear",
                fieldType: "checkbox",
                fieldLayoutClass: "checkbox-group",
                multiSelect: true,
                defaultValue: null,
                callback: (values, item) => {
                    // If no years are selected, show all
                    if (!values.length) return true;
                    
                    const year = parseInt(item.properties?.LatestPermitYear, 10);
                    if (!year || isNaN(year)) return false; // Skip if no valid year
                    
                    // Check if the item's year matches any of the selected years
                    return values.some(value => parseInt(value, 10) === year);
                },
                options: [
                    {
                        label: "2023",
                        value: "2023",
                    },
                    {
                        label: "2024",
                        value: "2024",
                    },
                    {
                        label: "2025",
                        value: "2025",
                    }
                ]
            }
        ];

        window.sqftCounts = {}; // collect counts for square footage ranges
        window.costCounts = {}; // collect counts for total construction cost ranges
        window.propertyTypeCounts = {}; // collect counts for property types
        window.unitCounts = {}; // collect counts for number of units ranges
        window.yearCounts = {}; // collect counts for latest permit years
        const fetchDataFilterCallback = (data) => {
            if (!data || !Array.isArray(data.features)) {
                console.warn("GeoJSON missing features array; received:", data);
                return { type: "FeatureCollection", features: [] };
            }

            // reset counts in case of re-load
            Object.keys(sqftCounts).forEach(k => delete sqftCounts[k]);
            Object.keys(costCounts).forEach(k => delete costCounts[k]);
            Object.keys(propertyTypeCounts).forEach(k => delete propertyTypeCounts[k]);
            Object.keys(unitCounts).forEach(k => delete unitCounts[k]);
            Object.keys(yearCounts).forEach(k => delete yearCounts[k]);

            const filteredFeatures = [];
            for (const item of data.features) {
                // All features are now included, status filtering removed
                filteredFeatures.push(item);
                
                // Calculate square footage counts
                const sqftValue = item.properties?.MaxSquareFootage;
                if (sqftValue !== undefined && sqftValue !== null) {
                    const sqft = typeof sqftValue === 'string' ? 
                        parseFloat(sqftValue.replace(/,/g, '')) : 
                        Number(sqftValue);
                        
                    if (!isNaN(sqft)) {
                        // Check which range this square footage falls into
                        if (sqft < 5000) {
                            sqftCounts['[0, 5000]'] = (sqftCounts['[0, 5000]'] || 0) + 1;
                        } else if (sqft < 10000) {
                            sqftCounts['[5000, 10000]'] = (sqftCounts['[5000, 10000]'] || 0) + 1;
                        } else if (sqft < 100000) {
                            sqftCounts['[10000, 100000]'] = (sqftCounts['[10000, 100000]'] || 0) + 1;
                        } else {
                            sqftCounts['[100000, 999999999999]'] = (sqftCounts['[100000, 999999999999]'] || 0) + 1;
                        }
                    }
                }
                
                // Calculate construction cost counts
                const costValue = item.properties?.MaxEstimatedValue;
                if (costValue !== undefined && costValue !== null) {
                    const cost = typeof costValue === 'string' ? 
                        parseFloat(costValue.replace(/,/g, '')) : 
                        Number(costValue);
                        
                    if (!isNaN(cost)) {
                        // Check which range this cost falls into
                        if (cost < 100000) {
                            costCounts['[0, 100000]'] = (costCounts['[0, 100000]'] || 0) + 1;
                        } else if (cost < 1000000) {
                            costCounts['[100000, 1000000]'] = (costCounts['[100000, 1000000]'] || 0) + 1;
                        } else if (cost < 10000000) {
                            costCounts['[1000000, 10000000]'] = (costCounts['[1000000, 10000000]'] || 0) + 1;
                        } else {
                            costCounts['[10000000, 999999999999]'] = (costCounts['[10000000, 999999999999]'] || 0) + 1;
                        }
                    }
                }
                
                // Calculate total number of units counts
                const unitsValue = item.properties?.MaxStructureUnits;
                if (unitsValue !== undefined && unitsValue !== null) {
                    const units = typeof unitsValue === 'string' ? 
                        parseFloat(unitsValue.replace(/,/g, '')) : 
                        Number(unitsValue);
                        
                    if (!isNaN(units)) {
                        // Check which range these units fall into
                        if (units < 1) {
                            unitCounts['[0, 1]'] = (unitCounts['[0, 1]'] || 0) + 1;
                        } else if (units < 2) {
                            unitCounts['[1, 2]'] = (unitCounts['[1, 2]'] || 0) + 1;
                        } else if (units < 4) {
                            unitCounts['[2, 4]'] = (unitCounts['[2, 4]'] || 0) + 1;
                        } else if (units < 10) {
                            unitCounts['[4, 10]'] = (unitCounts['[4, 10]'] || 0) + 1;
                        } else {
                            unitCounts['[10, 9999999999]'] = (unitCounts['[10, 9999999999]'] || 0) + 1;
                        }
                    }
                }
                
                // Calculate property type counts
                const propertyType = item.properties?.PropertyType;
                if (propertyType) {
                    // Increment count for this property type
                    if (propertyType.includes('Residential')) {
                        propertyTypeCounts['Residential'] = (propertyTypeCounts['Residential'] || 0) + 1;
                        
                        // Set the property type for coloring
                        if (!propertyType.includes('Commercial')) {
                            item.properties.PropertyType = 'Residential';
                        } else {
                            // If it contains both, it's a mixed-use property
                            item.properties.PropertyType = 'Other';
                            propertyTypeCounts['Other'] = (propertyTypeCounts['Other'] || 0) + 1;
                        }
                    } 
                    else if (propertyType.includes('Commercial')) {
                        propertyTypeCounts['Commercial'] = (propertyTypeCounts['Commercial'] || 0) + 1;
                        item.properties.PropertyType = 'Commercial';
                    }
                    else {
                        // Any other property types that don't match the above
                        propertyTypeCounts['Other'] = (propertyTypeCounts['Other'] || 0) + 1;
                        item.properties.PropertyType = 'Other';
                    }
                } else {
                    // Properties with no property type are categorized as Other
                    propertyTypeCounts['Other'] = (propertyTypeCounts['Other'] || 0) + 1;
                    item.properties.PropertyType = 'Other';
                }

                // Calculate year counts
                const yearValue = item.properties?.LatestPermitYear;
                if (yearValue !== undefined && yearValue !== null) {
                    const year = parseInt(yearValue, 10);
                    if (!isNaN(year)) {
                        // Increment count for this year
                        yearCounts[year.toString()] = (yearCounts[year.toString()] || 0) + 1;
                    }
                }
            }

                // Schedule an update for the filter labels after a short delay
                // This gives time for the DOM to be ready for the count display
                setTimeout(() => {
                    if (typeof window.refreshFilterCounts === 'function') {
                        console.log("Calling refreshFilterCounts from fetchDataFilterCallback");
                        window.refreshFilterCounts();
                    }
                }, 1500);

                return {
                    ...data,
                    features: filteredFeatures,
                };
            };        // Listen for mapbox load event to trigger property type filter update
        document.addEventListener('mapboxglLoaded', function () {
            console.log("Map loaded event received");
            setTimeout(() => {
                if (window.refreshFilterCounts) {
                    console.log("Refreshing filter counts after map load");
                    window.refreshFilterCounts();
                }
            }, 1000);
        });

        window.map = trdDataCommonMap({
            filePath: "https://static.therealdeal.com/interactive-maps/miami-construction-map.geojson",
            eventCategory: "miami-construction-map",
            mapElementId: "map",
            filterElementId: "map-filters",
            legendElementId: "legend",
            resultElementId: "result",
            mapCenterLat: 25.771293165956543,
            mapCenterLng: -80.19813878799437,
            zoom: 11,
            minZoom: 10,
            legendKeys,
            dataPointKeys: legendKeys[0].options,
            tooltipDisplayFields,
            modalDisplayFields,
            filterFields,
            fetchDataFilterCallback,
            loadingEnabled: true,
            pointSettings: {
                clickToCenter: true,
                clickToZoom: true,
                colorType: "case",
                radiusType: "radius",
                colorTypeDataKey: "PropertyType",
                paintSettings: {
                    color: {
                        light: "#8c42f5", // Default color (for points that don't match any case)
                        dark: "#a46af7"
                    },
                    hover: { color: { light: "#FF9800", dark: "#F57C00" } },
                    active: {
                        color: { light: "#FF5722", dark: "#D84315" }
                    },
                },
            },
            clusterSettings: {
                enable: true, // Whether to enable clustering
                maxZoom: 12, // Max zoom to cluster points on
                radius: 100, // Radius of each cluster when clustering points
                colorType: "case", // "case" // TODO: Add "step" support
                textSize: 16, // Size of the text in clusters
                paintSettings: {
                    default: {
                        color: {
                            light: "#1E85FF", // Default color for clusters in light mode
                            dark: "#1E85FF", // Default color for clusters in dark mode
                        },
                        textColor: {
                            light: "#ffffff", // Default text color for clusters in light mode
                            dark: "#ffffff", // Default text color for clusters in dark mode
                        },
                    },
                },
            }
        });

        // --- Filter count labels updater (status functionality removed) ---
        (function filterCounts() {
            function updateLabels() {
                const form = document.getElementById('map-filters');
                if (!form) {
                    console.log("Filter form not found");
                    return;
                }

                const optionContainers = form.querySelectorAll('.filter-option-container');
                if (!optionContainers.length) {
                    console.log("No filter option containers found");
                    return;
                }

                // Update all filter option containers
                optionContainers.forEach(container => {
                    const input = container.querySelector('input[name="sqft"], input[name="cost"], input[name="property-type"], input[name="units"], input[name="year"]');
                    const label = container.querySelector('label.filter-option');

                    if (!input || !label) {
                        return;
                    }

                    // store base label once
                    if (!label.dataset.baseLabel) {
                        label.dataset.baseLabel = label.textContent.replace(/\s*\(.*\)$/, '').trim();
                        console.log(`Set base label for ${input.value}: "${label.dataset.baseLabel}"`);
                    }

                    const value = input.value;
                    let count = 0;
                    
                    // Get count based on filter type
                    if (input.name === 'sqft') {
                        count = window.sqftCounts ? (window.sqftCounts[value] || 0) : 0;
                    } else if (input.name === 'cost') {
                        count = window.costCounts ? (window.costCounts[value] || 0) : 0;
                    } else if (input.name === 'property-type') {
                        count = window.propertyTypeCounts ? (window.propertyTypeCounts[value] || 0) : 0;
                    } else if (input.name === 'units') {
                        count = window.unitCounts ? (window.unitCounts[value] || 0) : 0;
                    } else if (input.name === 'year') {
                        count = window.yearCounts ? (window.yearCounts[value] || 0) : 0;
                    }
                    
                    label.textContent = `${label.dataset.baseLabel} (${count.toLocaleString()})`;
                });
            }

            // Try periodically until data & form ready
            let attempts = 0;
            const interval = setInterval(() => {
                attempts++;

                // Check if DOM and form are ready
                const formReady = document.getElementById('map-filters') !== null;

                // Always try to update - we want to keep trying even if initially unsuccessful
                updateLabels();

                // Only stop interval if form is ready and labels were updated
                if (formReady && document.querySelector('#map-filters label[data-base-label]')) {
                    clearInterval(interval);
                }

                if (attempts > 60) { // ~30s fallback
                    clearInterval(interval);
                }
            }, 500);

            // Public API to refresh after external filtering
            window.refreshFilterCounts = () => {
                console.log("Manual refresh of filter counts called");
                
                // Ensure we have the "Other" category initialized for the filter UI
                if (window.propertyTypeCounts && typeof window.propertyTypeCounts === 'object') {
                    window.propertyTypeCounts['Other'] = window.propertyTypeCounts['Other'] || 0;
                }
                
                updateLabels();
            };

            // Make the counts update after map data is loaded
            document.addEventListener('DOMContentLoaded', () => {
                console.log("DOM loaded - setting up additional trigger");

                // Add an observer to detect when the filter form is added to the DOM
                const observer = new MutationObserver((mutations) => {
                    for (const mutation of mutations) {
                        if (mutation.addedNodes.length) {
                            const filterForm = document.getElementById('map-filters');
                            if (filterForm) {
                                setTimeout(updateLabels, 1000); // Give some time for counts to be ready
                                observer.disconnect();
                                break;
                            }
                        }
                    }
                });

                // Start observing the body for when the filter form is added
                observer.observe(document.body, { childList: true, subtree: true });
            });

            // If a custom filtered event is dispatched with features, recompute counts
            document.addEventListener('trd:map:filtered', (e) => {
                console.log("Custom filtered event received");
                if (e.detail && Array.isArray(e.detail.features)) {
                    // recompute counts from provided feature set
                    const newSqftCounts = {};
                    const newCostCounts = {};
                    const newPropertyTypeCounts = {};
                    const newUnitCounts = {};
                    const newYearCounts = {};
                    
                    e.detail.features.forEach(f => {
                        // Square footage counts
                        const sqftValue = f.properties?.MaxSquareFootage;
                        if (sqftValue !== undefined && sqftValue !== null) {
                            const sqft = typeof sqftValue === 'string' ? 
                                parseFloat(sqftValue.replace(/,/g, '')) : 
                                Number(sqftValue);
                                
                            if (!isNaN(sqft)) {
                                if (sqft < 5000) {
                                    newSqftCounts['[0, 5000]'] = (newSqftCounts['[0, 5000]'] || 0) + 1;
                                } else if (sqft < 10000) {
                                    newSqftCounts['[5000, 10000]'] = (newSqftCounts['[5000, 10000]'] || 0) + 1;
                                } else if (sqft < 100000) {
                                    newSqftCounts['[10000, 100000]'] = (newSqftCounts['[10000, 100000]'] || 0) + 1;
                                } else {
                                    newSqftCounts['[100000, 999999999999]'] = (newSqftCounts['[100000, 999999999999]'] || 0) + 1;
                                }
                            }
                        }
                        
                        // Construction cost counts
                        const costValue = f.properties?.TotalCost;
                        if (costValue !== undefined && costValue !== null) {
                            const cost = typeof costValue === 'string' ? 
                                parseFloat(costValue.replace(/,/g, '')) : 
                                Number(costValue);
                                
                            if (!isNaN(cost)) {
                                if (cost < 100000) {
                                    newCostCounts['[0, 100000]'] = (newCostCounts['[0, 100000]'] || 0) + 1;
                                } else if (cost < 1000000) {
                                    newCostCounts['[100000, 1000000]'] = (newCostCounts['[100000, 1000000]'] || 0) + 1;
                                } else if (cost < 10000000) {
                                    newCostCounts['[1000000, 10000000]'] = (newCostCounts['[1000000, 10000000]'] || 0) + 1;
                                } else {
                                    newCostCounts['[10000000, 999999999999]'] = (newCostCounts['[10000000, 999999999999]'] || 0) + 1;
                                }
                            }
                        }
                        
                        // Property type counts
                        const propertyType = f.properties?.PropertyType;
                        if (propertyType) {
                            if (propertyType.includes('Residential')) {
                                newPropertyTypeCounts['Residential'] = (newPropertyTypeCounts['Residential'] || 0) + 1;
                            }
                            if (propertyType.includes('Commercial')) {
                                newPropertyTypeCounts['Commercial'] = (newPropertyTypeCounts['Commercial'] || 0) + 1;
                            }
                        }
                        
                        // Units counts for filtered features
                        const unitsValue = f.properties?.MaxStructureUnits;
                        if (unitsValue !== undefined && unitsValue !== null) {
                            const units = typeof unitsValue === 'string' ? 
                                parseFloat(unitsValue.replace(/,/g, '')) : 
                                Number(unitsValue);
                                
                            if (!isNaN(units)) {
                                if (units < 1) {
                                    newUnitCounts['[0, 1]'] = (newUnitCounts['[0, 1]'] || 0) + 1;
                                } else if (units < 2) {
                                    newUnitCounts['[1, 2]'] = (newUnitCounts['[1, 2]'] || 0) + 1;
                                } else if (units < 4) {
                                    newUnitCounts['[2, 4]'] = (newUnitCounts['[2, 4]'] || 0) + 1;
                                } else if (units < 10) {
                                    newUnitCounts['[4, 10]'] = (newUnitCounts['[4, 10]'] || 0) + 1;
                                } else {
                                    newUnitCounts['[10, 9999999999]'] = (newUnitCounts['[10, 9999999999]'] || 0) + 1;
                                }
                            }
                        }
                        // Year counts for filtered features
                        const yearValue = f.properties?.LatestPermitYear;
                        if (yearValue !== undefined && yearValue !== null) {
                            const year = parseInt(yearValue, 10);
                            if (!isNaN(year)) {
                                newYearCounts[year.toString()] = (newYearCounts[year.toString()] || 0) + 1;
                            }
                        }
                    });
                    
                    // replace global counts then refresh labels
                    Object.keys(sqftCounts).forEach(k => delete sqftCounts[k]);
                    Object.entries(newSqftCounts).forEach(([k, v]) => sqftCounts[k] = v);
                    
                    Object.keys(costCounts).forEach(k => delete costCounts[k]);
                    Object.entries(newCostCounts).forEach(([k, v]) => costCounts[k] = v);
                    
                    Object.keys(propertyTypeCounts).forEach(k => delete propertyTypeCounts[k]);
                    Object.entries(newPropertyTypeCounts).forEach(([k, v]) => propertyTypeCounts[k] = v);
                    
                    Object.keys(unitCounts).forEach(k => delete unitCounts[k]);
                    Object.entries(newUnitCounts).forEach(([k, v]) => unitCounts[k] = v);
                    Object.keys(yearCounts).forEach(k => delete yearCounts[k]);
                    Object.entries(newYearCounts).forEach(([k, v]) => yearCounts[k] = v);
                    
                    updateLabels();
                }
            });
        })();
        // --- End filter count labels updater ---
    </script>
</body>

</html>