<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Taxable Values Dashboard</title>

  <!-- Leaflet CSS (no integrity attribute) -->
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
  />

  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 20px;
    }

    #controls {
      margin-bottom: 20px;
    }

    #cards {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
      gap: 15px;
      margin-bottom: 20px;
    }

    .card {
      border: 1px solid #ddd;
      border-radius: 8px;
      padding: 15px;
      box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.1);
    }

    .card h3 {
      margin-top: 0;
      font-size: 1.1em;
    }

    .card p {
      margin: 5px 0;
      font-size: 1em;
    }

    label {
      font-weight: bold;
      margin-right: 10px;
    }

    select {
      padding: 5px;
      font-size: 1em;
    }

    #map {
      width: 100%;
      height: 500px;
      border: 1px solid #ccc;
      border-radius: 8px;
    }
  </style>
</head>

<body>
  <div id="controls">
    <label for="authoritySelect">Select Taxing Authority:</label>
    <select id="authoritySelect"></select>
  </div>

  <div id="cards"></div>

  <div id="map"></div>

  <!-- Leaflet JS -->
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <script>
    let geoJsonData = null;
    let map, geoJsonLayer, highlightLayer;

    // 1) Initialize the map & load GeoJSON on DOMContentLoaded
    document.addEventListener("DOMContentLoaded", () => {
      initializeMap();
      loadGeoJsonAndPopulate();
    });

    // 2) Initialize the Leaflet map (empty layers for now)
    function initializeMap() {
      // Default view centered roughly on Florida
      map = L.map("map").setView([27.7, -81.9], 7);

      L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
        maxZoom: 18,
        attribution:
          '&copy; <a href="https://openstreetmap.org">OpenStreetMap</a> contributors',
      }).addTo(map);

      // Placeholder empty GeoJSON layer; will be replaced when loading data
      geoJsonLayer = L.geoJSON(null).addTo(map);

      // Separate layer for highlighting the selected feature
      highlightLayer = L.geoJSON(null, {
        style: {
          color: "#ff0000",
          weight: 2,
          fillOpacity: 0.3,
        },
      }).addTo(map);
    }

    // 3) Load merged GeoJSON, build dropdown, and attach click handlers
    function loadGeoJsonAndPopulate() {
      fetch("merged_taxable_values.geojson")
        .then((resp) => resp.json())
        .then((geojson) => {
          geoJsonData = geojson;

          // Remove any pre-existing layer, then rebuild geoJsonLayer with onEachFeature
          if (geoJsonLayer) {
            map.removeLayer(geoJsonLayer);
          }

          geoJsonLayer = L.geoJSON(geoJsonData, {
            style: {
              color: "#3388ff",
              weight: 1,
              fillOpacity: 0.2,
            },
            onEachFeature: function (feature, layer) {
              // Attach a click listener to each polygon
              layer.on("click", function () {
                const authorityName = feature.properties["TAXING AUTHORITY"];
                // Update dropdown to match this authority
                const selectEl = document.getElementById("authoritySelect");
                selectEl.value = authorityName;
                // Update cards and highlight/zoom on this feature
                updateCards(authorityName);
                highlightAndZoom(feature);
              });
            },
          }).addTo(map);

          // Build dropdown from each featureâ€™s "TAXING AUTHORITY"
          const selectEl = document.getElementById("authoritySelect");
          geoJsonData.features.forEach((feat) => {
            const authorityName = feat.properties["TAXING AUTHORITY"];
            const opt = document.createElement("option");
            opt.value = authorityName;
            opt.textContent = authorityName;
            selectEl.appendChild(opt);
          });

          // When user selects from dropdown, find that feature and update
          selectEl.addEventListener("change", () => {
            const chosen = selectEl.value;
            updateCards(chosen);
            // Find matching feature in geoJsonData
            const feat = geoJsonData.features.find(
              (f) => f.properties["TAXING AUTHORITY"] === chosen
            );
            if (feat) {
              highlightAndZoom(feat);
            } else {
              // If none found, reset view and clear highlight
              highlightLayer.clearLayers();
              map.setView([27.7, -81.9], 7);
            }
          });

          // Initialize with the first feature
          if (geoJsonData.features.length > 0) {
            const firstAuthority =
              geoJsonData.features[0].properties["TAXING AUTHORITY"];
            selectEl.value = firstAuthority;
            updateCards(firstAuthority);
            highlightAndZoom(geoJsonData.features[0]);
          }
        })
        .catch((err) => {
          console.error("Error loading GeoJSON:", err);
        });
    }

    // 4) Update the cards panel based on the selected authority
    function updateCards(selectedAuthority) {
      if (!geoJsonData) return;

      // Find the matching GeoJSON feature
      const feat = geoJsonData.features.find(
        (f) => f.properties["TAXING AUTHORITY"] === selectedAuthority
      );
      if (!feat) return;

      const props = feat.properties;
      const cardsContainer = document.getElementById("cards");
      cardsContainer.innerHTML = "";

      const fields = [
        {
          label: "2024 Preliminary Value",
          key: "2024 PRELIMINARY TAXABLE VALUE",
        },
        {
          label: "2025 Before New Construction",
          key: "2025 ESTIMATED TAXABLE VALUE BEFORE NEW CONSTRUCTION",
        },
        {
          label: "Percent Change",
          key: "PERCENT CHANGE",
          isPercent: true,
        },
        { label: "New Construction", key: "NEW CONSTRUCTION" },
        { label: "2025 June 1 Estimate", key: "2025 JUNE 1ST ESTIMATE" },
        {
          label: "Percent Change From 2024",
          key: "PERCENT CHANGE FROM 2024",
          isPercent: true,
        },
        { label: "Net Change", key: "NET VALUE CHANGE" },
      ];

      fields.forEach((f) => {
        const card = document.createElement("div");
        card.className = "card";

        const title = document.createElement("h3");
        title.textContent = f.label;

        const valueEl = document.createElement("p");
        let rawVal = props[f.key];

        if (rawVal === null || rawVal === undefined) {
          valueEl.textContent = "N/A";
        } else if (f.isPercent) {
          // rawVal is already a string like "9.8%"
          valueEl.textContent = rawVal;
        } else {
          // Ensure rawVal is numeric
          const num = typeof rawVal === "string" ? Number(rawVal) : rawVal;
          valueEl.textContent = "$" + formatLargeNumber(num);
        }

        card.appendChild(title);
        card.appendChild(valueEl);
        cardsContainer.appendChild(card);
      });
    }

    // 5) Highlight a given GeoJSON feature and zoom to its bounds
    function highlightAndZoom(feature) {
      highlightLayer.clearLayers();
      highlightLayer.addData(feature);

      // Compute bounds by creating a temporary layer
      const tempLayer = L.geoJSON(feature);
      map.fitBounds(tempLayer.getBounds().pad(0.25), {
        animate: true,
        duration: 0.5,
      });
    }

    // 6) Condense a large number into M/B (millions/billions) or comma format
    function formatLargeNumber(num) {
      const absNum = Math.abs(num);
      if (absNum >= 1e9) {
        return (num / 1e9).toFixed(1) + "B";
      }
      if (absNum >= 1e6) {
        return (num / 1e6).toFixed(1) + "M";
      }
      return num.toLocaleString("en-US");
    }
  </script>
</body>
</html>
