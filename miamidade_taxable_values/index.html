<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Taxable Values Dashboard</title>

  <!-- Leaflet CSS -->
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
  />

  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 20px;
    }

    #controls {
      margin-bottom: 20px;
    }

    #cards {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
      gap: 15px;
      margin-bottom: 20px;
    }

    .card {
      border: 1px solid #ddd;
      border-radius: 8px;
      padding: 15px;
      box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.1);
    }

    .card h3 {
      margin-top: 0;
      font-size: 1.1em;
    }

    .card p {
      margin: 5px 0;
      font-size: 1em;
    }

    label {
      font-weight: bold;
      margin-right: 10px;
    }

    select {
      padding: 5px;
      font-size: 1em;
    }

    #map {
      width: 100%;
      height: 500px;
      border: 1px solid #ccc;
      border-radius: 8px;
    }
  </style>
</head>

<body>
  <div id="controls">
    <label for="authoritySelect">Select Taxing Authority:</label>
    <select id="authoritySelect"></select>
  </div>

  <div id="cards"></div>

  <div id="map"></div>

  <!-- Leaflet JS -->
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <script>
    let geoJsonData = null;
    let map, geoJsonLayer, highlightLayer;

    document.addEventListener("DOMContentLoaded", () => {
      initializeMap();
      loadGeoJsonAndPopulate();
    });

    function initializeMap() {
      map = L.map("map").setView([27.7, -81.9], 7);

      L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
        maxZoom: 18,
        attribution:
          '&copy; <a href="https://openstreetmap.org">OpenStreetMap</a> contributors',
      }).addTo(map);

      geoJsonLayer = L.geoJSON(null).addTo(map);

      highlightLayer = L.geoJSON(null, {
        style: {
          color: "#ff0000",
          weight: 2,
          fillOpacity: 0.3,
        },
      }).addTo(map);
    }

    function loadGeoJsonAndPopulate() {
      fetch("merged_taxable_values.geojson")
        .then((resp) => resp.json())
        .then((geojson) => {
          geoJsonData = geojson;

          // Rebuild geoJsonLayer with click handlers
          if (geoJsonLayer) {
            map.removeLayer(geoJsonLayer);
          }

          geoJsonLayer = L.geoJSON(geoJsonData, {
            style: {
              color: "#3388ff",
              weight: 1,
              fillOpacity: 0.2,
            },
            onEachFeature: function (feature, layer) {
              layer.on("click", function () {
                const authorityName = feature.properties["TAXING AUTHORITY"];
                const selectEl = document.getElementById("authoritySelect");
                selectEl.value = authorityName;
                updateCards(authorityName);
                highlightAndZoom(feature);
              });
            },
          }).addTo(map);

          // Extract and sort all authority names
          const authorityNames = geoJsonData.features
            .map((f) => f.properties["TAXING AUTHORITY"])
            .sort((a, b) => a.localeCompare(b));

          const selectEl = document.getElementById("authoritySelect");
          authorityNames.forEach((name) => {
            const opt = document.createElement("option");
            opt.value = name;
            opt.textContent = name;
            selectEl.appendChild(opt);
          });

          selectEl.addEventListener("change", () => {
            const chosen = selectEl.value;
            updateCards(chosen);
            // Find matching feature
            const feat = geoJsonData.features.find(
              (f) => f.properties["TAXING AUTHORITY"] === chosen
            );
            if (feat) {
              highlightAndZoom(feat);
            } else {
              highlightLayer.clearLayers();
              map.setView([27.7, -81.9], 7);
            }
          });

          // Initialize with the first (alphabetical) authority
          if (authorityNames.length > 0) {
            const firstAuthority = authorityNames[0];
            selectEl.value = firstAuthority;
            updateCards(firstAuthority);
            const firstFeature = geoJsonData.features.find(
              (f) => f.properties["TAXING AUTHORITY"] === firstAuthority
            );
            if (firstFeature) {
              highlightAndZoom(firstFeature);
            }
          }
        })
        .catch((err) => {
          console.error("Error loading GeoJSON:", err);
        });
    }

    function updateCards(selectedAuthority) {
      if (!geoJsonData) return;

      const feat = geoJsonData.features.find(
        (f) => f.properties["TAXING AUTHORITY"] === selectedAuthority
      );
      if (!feat) return;

      const props = feat.properties;
      const cardsContainer = document.getElementById("cards");
      cardsContainer.innerHTML = "";

      const fields = [
        {
          label: "2024 Preliminary Value",
          key: "2024 PRELIMINARY TAXABLE VALUE",
        },
        {
          label: "2025 Before New Construction",
          key: "2025 ESTIMATED TAXABLE VALUE BEFORE NEW CONSTRUCTION",
        },
        {
          label: "Percent Change",
          key: "PERCENT CHANGE",
          isPercent: true,
        },
        { label: "New Construction", key: "NEW CONSTRUCTION" },
        { label: "2025 June 1 Estimate", key: "2025 JUNE 1ST ESTIMATE" },
        {
          label: "Percent Change From 2024",
          key: "PERCENT CHANGE FROM 2024",
          isPercent: true,
        },
        { label: "Net Change", key: "NET VALUE CHANGE" },
      ];

      fields.forEach((f) => {
        const card = document.createElement("div");
        card.className = "card";

        const title = document.createElement("h3");
        title.textContent = f.label;

        const valueEl = document.createElement("p");
        let rawVal = props[f.key];

        if (rawVal === null || rawVal === undefined) {
          valueEl.textContent = "N/A";
        } else if (f.isPercent) {
          valueEl.textContent = rawVal; // e.g. "9.8%"
        } else {
          const num = typeof rawVal === "string" ? Number(rawVal) : rawVal;
          valueEl.textContent = "$" + formatLargeNumber(num);
        }

        card.appendChild(title);
        card.appendChild(valueEl);
        cardsContainer.appendChild(card);
      });
    }

    function highlightAndZoom(feature) {
      highlightLayer.clearLayers();
      highlightLayer.addData(feature);

      const tempLayer = L.geoJSON(feature);
      map.fitBounds(tempLayer.getBounds().pad(0.25), {
        animate: true,
        duration: 0.5,
      });
    }

    function formatLargeNumber(num) {
      const absNum = Math.abs(num);
      if (absNum >= 1e9) {
        return (num / 1e9).toFixed(1) + "B";
      }
      if (absNum >= 1e6) {
        return (num / 1e6).toFixed(0) + "M";
      }
      return num.toLocaleString("en-US");
    }
  </script>
</body>
</html>
